# ###################################################################################################
# #Sardar Hamidian 06-30-2016
# #Reading dicom files and creating 3D-numpy array
# #Input the root directory into dicom directory
# #Output 3D numpy directory with the same directory structure
# #
import dicom
import os
import numpy as np
import sys
import glob
###########################################################################################
# main pipline for crating the 3d matrix out of dicom files
###########################################################################################
z_hash={}
all_cases=[]
# PathDicom = "./input_dicom/"
##############################################
######### Inputs #############################
PathDicom = "/raida/apezeshk/lung_dicom_dir/"
# Note: Alternative to setting values above/below thresholds to a fixed value is to just calculate min/max as if
# those values didn't exist (i.e. first removing them, then computing max/min), but not change the actual values in 
# the stored numpy array. So that is the route Find_max_min takes (it uses the regular numpy directory, and does the 
# thing above, instead of working off of the _mod directory generated by setting modFlag=1 below)
outputDirectory='/diskStation/LIDC/LIDC_NUMPY_3d' #change this folder per modFlag; 
#outputDirectory='/raida/apezeshk/temp/3dNumpyProblemCases' #change this folder per modFlag; 
modFlag = 0 #if 0, just reads and writes to numpy array; if 1, sets values above and below a threshold to a constant
threshMax = 4000 #only used if modFlag==1; values above this will be set to max of volume if those values are removed
threshMin = -4000#only used if modFlag==1; values below this will be set to min of volume if those values are removed
######### Inputs #############################
##############################################

if os.path.exists(PathDicom) :
    print "Directory name: %s exists" % (PathDicom)
else:
    sys.exit("%s directory with dicom cases could not be found!" % (PathDicom))
    
if os.path.exists(outputDirectory) :
    print "Output directory name: %s exists" % (outputDirectory)
else:
    print "Creating output directory name: %s " % (outputDirectory)
    os.mkdir(outputDirectory)
    
    
def dic_dir(pathdicom):
    #lstFilesDCM = []  # create an empty list
    tmp = ''
    lstFilesDCM = []
    for dirName, subdirList, fileList in os.walk(pathdicom):
        for filename in fileList:
            if ".dcm" in filename.lower():  # check whether the file's DICOM
                if tmp!=dirName:
                    tmp=dirName
                    lstFilesDCM.append(dirName)
    return(lstFilesDCM)
#def path_create(file_name):
#    spl_dir=file_name[:].replace('_','/')
#    return spl_dir
def Create_3d(input_dir,outputdir=''):
    for cases in dic_dir(input_dir):
         ##################################################################################
         ### If you want to run specific cases from list of all available cases, uncomment 
         ### following lines and put the patient ID in below 
         ##################################################################################
#        if ('p0490' not in cases) and ('p0566' not in cases) and ('p0942' not in cases):
#            continue        
        
        if len(os.listdir(cases))<=20: #Useless check, don't think we have any such folders, but whatever
            print "There are a few number to be processed so case %d" %(cases,)+" is removed"
        else:
            patientIdParts = cases.replace(input_dir, '') #first take out the master folder from the full case path
            patientIdParts = patientIdParts.replace('/', '_')
            if patientIdParts[0]=='_':
                patientIdParts = list(patientIdParts) #convert to list s.t. you can remove specific element, then back to str
                patientIdParts.remove('_') #will remove first instance of '_'
                patientIdParts = ''.join(patientIdParts)
                        
            filenameOut = os.path.join(outputdir, patientIdParts+".npy")
            ##################################################################################
            ### If you want to skip rebuilding cases that were previously done, use the if statement,
            ### otherwise comment it out!!!
            ##################################################################################
            if os.path.exists(filenameOut):
                continue
            
            ind=1 #arbitrary index; just to start the search for any dcm file used to read header info
            # #to get header info, just find some file that is a dicom and not any other file
            while  ".dcm" not in os.listdir(cases)[ind].lower():
                 ind+=1
            RefDs = dicom.read_file(str(cases) + '/' + str(os.listdir(cases)[ind]))
            dcmCounter = len(glob.glob1(cases, "*.dcm"))
          # Creates an empty list
            ConstPixelDims = (int(RefDs.Rows), int(RefDs.Columns), dcmCounter)#should come back 512x512xnumberOfSlices
            dic_3d = np.zeros(ConstPixelDims, dtype=RefDs.pixel_array.dtype)
            dic_temp = np.zeros(ConstPixelDims, dtype=RefDs.pixel_array.dtype) #for cases w problem in InstanceID, first put slices in this array & then put them in dic_3d
            try:
            # loop through all the DICOM files
                minSliceNumber = 10000 # will be the lowest slice number.
                maxSliceNumber = 0 # will be the highest slice number.
                sliceExists = [] #will contain all InstanceNumbers from the dicoms (different from how it was done in matlab)
                ind_temp = 0
                instanceNumArray = np.zeros((dcmCounter,)) #stores for each file, what instanceNumber it had
                for filenameDCM in os.listdir(cases):
                    if '.dcm' not in filenameDCM:
                        continue
                    
                    #filePartToUse = str(filenameDCM) #it is needed from any of the dicom files;
                    currentDicomInfo = dicom.read_file(os.path.join(str(cases), filenameDCM))
                    minSliceNumber = min(minSliceNumber, int(currentDicomInfo.InstanceNumber));
                    maxSliceNumber = max(maxSliceNumber, int(currentDicomInfo.InstanceNumber));
                    sliceExists.append(currentDicomInfo.InstanceNumber)
                    currentIm=currentDicomInfo.pixel_array
                    currentIm=(currentIm*currentDicomInfo.RescaleSlope)+(currentDicomInfo.RescaleIntercept)
                    dic_temp[:,:,ind_temp] = currentIm.astype(np.int16)
                    instanceNumArray[ind_temp] = int(currentDicomInfo.InstanceNumber)
                    ind_temp = ind_temp + 1
                    
                # check if the image numbers are between 1 and nSliceCount, and all slices exist (if any sliceExists item is 0, a slice is missing).    
                if minSliceNumber != 1 or maxSliceNumber != dcmCounter or not(set(range(1,dcmCounter+1))==set(sliceExists)):
                #In some cases, InstanceNumber starts from number other than 1;
                #check if current case is one of those, and if so, shift everything
                #left according to amount of shift. e.g. p0158 (starts from 315) or p0306
                    if minSliceNumber!=1 and (minSliceNumber+dcmCounter-1) == maxSliceNumber and set(range(minSliceNumber,(minSliceNumber+dcmCounter)))==set(sliceExists):
                        sliceNumShift = minSliceNumber; #if starting InstanceNumber is different than 1, you need to shift everything accordingly
                        minSliceNumber = minSliceNumber - sliceNumShift + 1; #min slice should start from 1
                        maxSliceNumber = maxSliceNumber - sliceNumShift + 1;
                        for i in range(0,dcmCounter):
                            dic_3d[:,:,i] = dic_temp[:,:,np.where(instanceNumArray==(i+sliceNumShift))[0][0]]
                            
                    elif 'p0807' in cases:
                        actualMissingSlice = 282 #actual InstanceNumber that is missing; 
                        #for slices>=actualMissingSlice, the instanceNumbers should be shifted by extra 1 to account
                        #for the missing slice;
                        for i in range(0,dcmCounter):
                            if i<(actualMissingSlice-1):
                                dic_3d[:,:,i] = dic_temp[:,:,np.where(instanceNumArray==(i+1))[0][0]]
                            else:
                                dic_3d[:,:,i] = dic_temp[:,:,np.where(instanceNumArray==(i+2))[0][0]]
                    
                    elif 'p0807' not in cases:
                        #p0807 is actually missing a slice, but is part of
                        #LUNA; so don't skip it, instead handle the specific missing slice right after 280 (when slice index counted from 1)!
                        print 'Some slices are missing in %s' %(cases,)                        
                        continue
                        
                else: #if the case doesn't have anything funny going on with it, ordering is right so set dic_3d to dic_temp
                    for i in range(0,dcmCounter):
                            dic_3d[:,:,i] = dic_temp[:,:,np.where(instanceNumArray==(i+1))[0][0]]
                    
                
                     
#                for filenameDCM in os.listdir(cases):
#                    # read the file
#                    #dic_3d=ArrayDicom #ok to do this way, bc np arrays are mutable, but commented bc it is confusing 
#                    if filenameDCM[-3:]=="dcm":
#                        ds = dicom.read_file(str(cases)+'/'+filenameDCM)
#                        im=ds.pixel_array
#                        im=(im*ds.RescaleSlope)+(ds.RescaleIntercept)                      
#
#                        dic_3d[:, :, (ds.InstanceNumber)-1] = im.astype(np.int16)
#                        filename=str(filenameDCM)
             
             
                if modFlag==1: #set values above (below) threshMax (threshMin) to max (min) values without them
                    tmp = np.zeros(dic_3d.shape, dtype=np.int16)
                    tmp[dic_3d<threshMax] = dic_3d[dic_3d<threshMax] #zero out outliers, and find new max from rest of volume
                    max_mod = tmp.max()
                    tmp = np.zeros(dic_3d.shape, dtype=np.int16) #now do same as above, but for negative outliers 
                    tmp[dic_3d>threshMin] = dic_3d[dic_3d>threshMin]
                    min_mod = tmp.min()
                    dic_3d[dic_3d>=threshMax] = max_mod
                    dic_3d[dic_3d<=threshMin] = min_mod

                #np.save(outputdir+'/'+filename[:-8]+".npy",dic_3d) #get rid of the _###.dcm so 8 indices to remove
                #np.save(os.path.join(outputdir, filePartToUse[:-8]+".npy"), dic_3d) #get rid of the _###.dcm so 8 indices to remove
                #print "3D dicom %s is built as numpy array" % (outputdir+'/'+filePartToUse[:-8]+".npy")
                np.save(filenameOut, dic_3d) #get rid of the _###.dcm so 8 indices to remove
                print "%s is built as numpy array" % (filenameOut)
            
            except(KeyboardInterrupt):
                sys.exit(0)
            except:
                print "3D dicom %s is not built as numpy array, something went wrong!" % (str(cases))
                print sys.exc_info()

if __name__ == '__main__':
    Create_3d(PathDicom,outputDirectory)























